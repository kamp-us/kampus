# Relay Node Interface

## Feature Overview

Implement the Relay Node interface specification to enable Relay's fragment directives (`@refetchable`, `@argumentDefinitions`, etc.) on the frontend. This is foundational infrastructure for keeping React components clean and leveraging Relay's automatic data management.

## Motivation

Without a Node interface, Relay fragments cannot use `@refetchable` because there's no way to re-fetch an individual node by its ID. The Node interface provides:

1. **`@refetchable` support** - Fragments can declare refetch queries automatically generated by Relay
2. **Cache normalization** - Relay can properly normalize and cache entities by global ID
3. **Consistent ID handling** - All entities have globally unique, opaque IDs

## User Stories

### As a frontend developer
- I want to use `@refetchable` on fragments so that I can refresh individual components without refetching entire queries
- I want Relay to handle cache normalization automatically so that updates propagate across the UI
- I want opaque global IDs so that the frontend doesn't need to know about backend ID schemes

### As a backend developer
- I want a simple pattern for making types implement Node so that adding new node types is straightforward
- I want the Node query to be authorization-aware so that users can only fetch their own data

## Acceptance Criteria

### Node Interface
- [ ] GraphQL schema includes `interface Node { id: ID! }`
- [ ] `Story` type implements Node interface
- [ ] Global IDs are base64-encoded in format `Type:localId`

### Node Query
- [ ] `node(id: ID!): Node` query exists at schema root
- [ ] Query decodes global ID to determine type and local ID
- [ ] Query fetches from authenticated user's Library DO
- [ ] Returns `null` if node not found or user not authenticated
- [ ] Type is resolved correctly (Story returns as Story type)

### Utilities
- [ ] `encodeGlobalId(type: string, id: string): string` utility function
- [ ] `decodeGlobalId(globalId: string): { type: string, id: string }` utility function
- [ ] Utilities are reusable across resolvers

### Frontend Compatibility
- [ ] Relay compiler accepts `@refetchable` on Story fragments
- [ ] Generated refetch queries work correctly
- [ ] Schema fetch (`pnpm --filter kamp-us run schema:fetch`) succeeds

## Technical Approach

### Scoping to Authenticated User

The Node query is scoped to the authenticated user's data:

```
node(id: "U3Rvcnk6c3RvcnlfYWJj")
  → decode → { type: "Story", id: "story_abc" }
  → get userId from context.pasaport.user.id
  → env.LIBRARY.idFromName(userId)
  → library.getStory("story_abc")
  → return story or null
```

This approach:
- Requires no additional data stores
- Provides implicit authorization (users can only fetch their own nodes)
- Works with existing Library DO architecture
- Follows KISS principle

### Global ID Format

Base64-encoded `Type:localId`:
- `Story:story_abc123` → `U3Rvcnk6c3RvcnlfYWJjMTIz`
- Opaque to clients (they should treat it as an opaque string)
- Decodable on server for routing

## Constraints

- Must work with GQLoom schema definition patterns
- Must integrate with existing Effect Schema types
- Node query must be authenticated (return null for anonymous requests)
- No changes to Library DO internal storage schema

## Dependencies

- Existing Library DO with `getStory(id)` method (may need to add if not present)
- GQLoom interface support
- Relay compiler on frontend

## Out of Scope

- `nodes(ids: [ID!]!): [Node]!` batch query (can add later if needed)
- Cross-user node lookups (public/shared content)
- Tag type implementing Node (can add in follow-up)
- Connection-level `@refetchable` (only fragment-level for now)
